// This is automatically generated by the Tiger compiler.
// Do NOT modify!

extern void* prev;
//vtable structures declaration
struct TreeVisitor_vtable;
struct TV_vtable;
struct Tree_vtable;
struct Visitor_vtable;
struct MyVisitor_vtable;
// structures
struct TreeVisitor_class
{
  struct TreeVisitor_vtable *vptr;
int isObjOrArray;
void *forwarding;
unsigned mark;
};
struct TV_class
{
  struct TV_vtable *vptr;
int isObjOrArray;
void *forwarding;
unsigned mark;
};
struct Tree_class
{
  struct Tree_vtable *vptr;
int isObjOrArray;
void *forwarding;
unsigned mark;
struct Tree_class *left;
struct Tree_class *right;
int key;
int has_left;
int has_right;
struct Tree_class *my_null;
};
struct Visitor_class
{
  struct Visitor_vtable *vptr;
int isObjOrArray;
void *forwarding;
unsigned mark;
struct Tree_class *l;
struct Tree_class *r;
};
struct MyVisitor_class
{
  struct MyVisitor_vtable *vptr;
int isObjOrArray;
void *forwarding;
unsigned mark;
struct Tree_class *l;
struct Tree_class *r;
};
// vtables structures
struct TreeVisitor_vtable
{
char* TreeVisitor_gc_map;
};

struct TV_vtable
{
char* TV_gc_map;
  int  (*Start)(struct TV_class *this);
};

struct Tree_vtable
{
char* Tree_gc_map;
  int  (*Init)(struct Tree_class *this,int  v_key);
  int  (*SetRight)(struct Tree_class *this,struct Tree_class * rn);
  int  (*SetLeft)(struct Tree_class *this,struct Tree_class * ln);
  struct Tree_class * (*GetRight)(struct Tree_class *this);
  struct Tree_class * (*GetLeft)(struct Tree_class *this);
  int  (*GetKey)(struct Tree_class *this);
  int  (*SetKey)(struct Tree_class *this,int  v_key);
  int  (*GetHas_Right)(struct Tree_class *this);
  int  (*GetHas_Left)(struct Tree_class *this);
  int  (*SetHas_Left)(struct Tree_class *this,int  val);
  int  (*SetHas_Right)(struct Tree_class *this,int  val);
  int  (*Compare)(struct Tree_class *this,int  num1,int  num2);
  int  (*Insert)(struct Tree_class *this,int  v_key);
  int  (*Delete)(struct Tree_class *this,int  v_key);
  int  (*Remove)(struct Tree_class *this,struct Tree_class * p_node,struct Tree_class * c_node);
  int  (*RemoveRight)(struct Tree_class *this,struct Tree_class * p_node,struct Tree_class * c_node);
  int  (*RemoveLeft)(struct Tree_class *this,struct Tree_class * p_node,struct Tree_class * c_node);
  int  (*Search)(struct Tree_class *this,int  v_key);
  int  (*Print)(struct Tree_class *this);
  int  (*RecPrint)(struct Tree_class *this,struct Tree_class * node);
  int  (*accept)(struct Tree_class *this,struct Visitor_class * v);
};

struct Visitor_vtable
{
char* Visitor_gc_map;
  int  (*visit)(struct Visitor_class *this,struct Tree_class * n);
};

struct MyVisitor_vtable
{
char* MyVisitor_gc_map;
  int  (*visit)(struct MyVisitor_class *this,struct Tree_class * n);
};


// forward declare vtable
struct TreeVisitor_vtable TreeVisitor_vtable_; 
struct TV_vtable TV_vtable_; 
struct Tree_vtable Tree_vtable_; 
struct Visitor_vtable Visitor_vtable_; 
struct MyVisitor_vtable MyVisitor_vtable_; 
// methods
  struct TV_Start_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct Tree_class * root;
  struct MyVisitor_class * v;
  struct Tree_class * x_1;
  struct Tree_class * x_2;
  struct Tree_class * x_3;
  struct Tree_class * x_4;
  struct Tree_class * x_5;
  struct Tree_class * x_6;
  struct Tree_class * x_7;
  struct Tree_class * x_8;
  struct Tree_class * x_9;
  struct Tree_class * x_10;
  struct Tree_class * x_11;
  struct Tree_class * x_12;
  struct Tree_class * x_13;
  struct Tree_class * x_14;
  struct Tree_class * x_15;
  struct Tree_class * x_16;
  struct Tree_class * x_17;
  struct Tree_class * x_18;
  struct Tree_class * x_19;
};

int  TV_Start(struct TV_class * this)
{
  struct TV_Start_gc_frame frame;

  int ntb;
  int nti;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 21;
frame.root = 0;
frame.v = 0;
frame.x_1 = 0;
frame.x_2 = 0;
frame.x_3 = 0;
frame.x_4 = 0;
frame.x_5 = 0;
frame.x_6 = 0;
frame.x_7 = 0;
frame.x_8 = 0;
frame.x_9 = 0;
frame.x_10 = 0;
frame.x_11 = 0;
frame.x_12 = 0;
frame.x_13 = 0;
frame.x_14 = 0;
frame.x_15 = 0;
frame.x_16 = 0;
frame.x_17 = 0;
frame.x_18 = 0;
frame.x_19 = 0;

  frame.root = ((struct Tree_class*)(Tiger_new (&Tree_vtable_, sizeof(struct Tree_class)/4 )));
  ntb = (frame.x_1=frame.root, frame.x_1->vptr->Init(frame.x_1, 16));
  ntb = (frame.x_2=frame.root, frame.x_2->vptr->Print(frame.x_2));
  System_out_println (100000000);
  ntb = (frame.x_3=frame.root, frame.x_3->vptr->Insert(frame.x_3, 8));
  ntb = (frame.x_4=frame.root, frame.x_4->vptr->Insert(frame.x_4, 24));
  ntb = (frame.x_5=frame.root, frame.x_5->vptr->Insert(frame.x_5, 4));
  ntb = (frame.x_6=frame.root, frame.x_6->vptr->Insert(frame.x_6, 12));
  ntb = (frame.x_7=frame.root, frame.x_7->vptr->Insert(frame.x_7, 20));
  ntb = (frame.x_8=frame.root, frame.x_8->vptr->Insert(frame.x_8, 28));
  ntb = (frame.x_9=frame.root, frame.x_9->vptr->Insert(frame.x_9, 14));
  ntb = (frame.x_10=frame.root, frame.x_10->vptr->Print(frame.x_10));
  System_out_println (100000000);
  frame.v = ((struct MyVisitor_class*)(Tiger_new (&MyVisitor_vtable_, sizeof(struct MyVisitor_class)/4 )));
  System_out_println (50000000);
  nti = (frame.x_11=frame.root, frame.x_11->vptr->accept(frame.x_11, frame.v));
  System_out_println (100000000);
  System_out_println ((frame.x_12=frame.root, frame.x_12->vptr->Search(frame.x_12, 24)));
  System_out_println ((frame.x_13=frame.root, frame.x_13->vptr->Search(frame.x_13, 12)));
  System_out_println ((frame.x_14=frame.root, frame.x_14->vptr->Search(frame.x_14, 16)));
  System_out_println ((frame.x_15=frame.root, frame.x_15->vptr->Search(frame.x_15, 50)));
  System_out_println ((frame.x_16=frame.root, frame.x_16->vptr->Search(frame.x_16, 12)));
  ntb = (frame.x_17=frame.root, frame.x_17->vptr->Delete(frame.x_17, 12));
  ntb = (frame.x_18=frame.root, frame.x_18->vptr->Print(frame.x_18));
  System_out_println ((frame.x_19=frame.root, frame.x_19->vptr->Search(frame.x_19, 12)));

  prev = frame.prev;

  return 0;
}
  struct Tree_Init_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

int  Tree_Init(struct Tree_class * this, int  v_key)
{
  struct Tree_Init_gc_frame frame;

  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "0";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;

  this->key = v_key;
  this->has_left = 0;
  this->has_right = 0;

  prev = frame.prev;

  return (int)(1);
}
  struct Tree_SetRight_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

int  Tree_SetRight(struct Tree_class * this, struct Tree_class * rn)
{
  struct Tree_SetRight_gc_frame frame;

  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "1";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;

  Interceptor(this->right , rn);
  this->right = rn;

  prev = frame.prev;

  return (int)(1);
}
  struct Tree_SetLeft_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

int  Tree_SetLeft(struct Tree_class * this, struct Tree_class * ln)
{
  struct Tree_SetLeft_gc_frame frame;

  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "1";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;

  Interceptor(this->left , ln);
  this->left = ln;

  prev = frame.prev;

  return (int)(1);
}
  struct Tree_GetRight_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

struct Tree_class * Tree_GetRight(struct Tree_class * this)
{
  struct Tree_GetRight_gc_frame frame;

  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;


  prev = frame.prev;

  return this->right;
}
  struct Tree_GetLeft_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

struct Tree_class * Tree_GetLeft(struct Tree_class * this)
{
  struct Tree_GetLeft_gc_frame frame;

  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;


  prev = frame.prev;

  return this->left;
}
  struct Tree_GetKey_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

int  Tree_GetKey(struct Tree_class * this)
{
  struct Tree_GetKey_gc_frame frame;

  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;


  prev = frame.prev;

  return this->key;
}
  struct Tree_SetKey_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

int  Tree_SetKey(struct Tree_class * this, int  v_key)
{
  struct Tree_SetKey_gc_frame frame;

  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "0";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;

  this->key = v_key;

  prev = frame.prev;

  return (int)(1);
}
  struct Tree_GetHas_Right_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

int  Tree_GetHas_Right(struct Tree_class * this)
{
  struct Tree_GetHas_Right_gc_frame frame;

  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;


  prev = frame.prev;

  return (int)(this->has_right);
}
  struct Tree_GetHas_Left_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

int  Tree_GetHas_Left(struct Tree_class * this)
{
  struct Tree_GetHas_Left_gc_frame frame;

  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;


  prev = frame.prev;

  return (int)(this->has_left);
}
  struct Tree_SetHas_Left_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

int  Tree_SetHas_Left(struct Tree_class * this, int  val)
{
  struct Tree_SetHas_Left_gc_frame frame;

  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "0";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;

  this->has_left = val;

  prev = frame.prev;

  return (int)(1);
}
  struct Tree_SetHas_Right_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

int  Tree_SetHas_Right(struct Tree_class * this, int  val)
{
  struct Tree_SetHas_Right_gc_frame frame;

  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "0";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;

  this->has_right = val;

  prev = frame.prev;

  return (int)(1);
}
  struct Tree_Compare_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

int  Tree_Compare(struct Tree_class * this, int  num1, int  num2)
{
  struct Tree_Compare_gc_frame frame;

  int ntb;
  int nti;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "00";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;

  ntb = 0;
  nti = num2 + 1;
  if ((num1) < (num2))
    {
    ntb = 0;
    }

  else
    {
    if (!((num1) < (nti)))
      {
      ntb = 0;
      }

    else
      {
      ntb = 1;
      }

    }


  prev = frame.prev;

  return (int)(ntb);
}
  struct Tree_Insert_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct Tree_class * new_node;
  struct Tree_class * current_node;
  struct Tree_class * x_20;
  struct Tree_class * x_21;
  struct Tree_class * x_22;
  struct Tree_class * x_23;
  struct Tree_class * x_24;
  struct Tree_class * x_25;
  struct Tree_class * x_26;
  struct Tree_class * x_27;
  struct Tree_class * x_28;
  struct Tree_class * x_29;
};

int  Tree_Insert(struct Tree_class * this, int  v_key)
{
  struct Tree_Insert_gc_frame frame;

  int ntb;
  int cont;
  int key_aux;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "0";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 12;
frame.new_node = 0;
frame.current_node = 0;
frame.x_20 = 0;
frame.x_21 = 0;
frame.x_22 = 0;
frame.x_23 = 0;
frame.x_24 = 0;
frame.x_25 = 0;
frame.x_26 = 0;
frame.x_27 = 0;
frame.x_28 = 0;
frame.x_29 = 0;

  frame.new_node = ((struct Tree_class*)(Tiger_new (&Tree_vtable_, sizeof(struct Tree_class)/4 )));
  ntb = (frame.x_20=frame.new_node, frame.x_20->vptr->Init(frame.x_20, v_key));
  frame.current_node = this;
  cont = 1;
  while(cont)
  {
{
  key_aux = (frame.x_21=frame.current_node, frame.x_21->vptr->GetKey(frame.x_21));
  if ((v_key) < (key_aux))
    {
{
    if ((frame.x_22=frame.current_node, frame.x_22->vptr->GetHas_Left(frame.x_22)))
      {
      struct Tree *temp_x_23;
      temp_x_23 = (frame.x_23=frame.current_node, frame.x_23->vptr->GetLeft(frame.x_23));
      Interceptor(frame.current_node , temp_x_23);
      frame.current_node = temp_x_23;
      }

    else
      {
{
      cont = 0;
      ntb = (frame.x_24=frame.current_node, frame.x_24->vptr->SetHas_Left(frame.x_24, 1));
      ntb = (frame.x_25=frame.current_node, frame.x_25->vptr->SetLeft(frame.x_25, frame.new_node));
}
      }

}
    }

  else
    {
{
    if ((frame.x_26=frame.current_node, frame.x_26->vptr->GetHas_Right(frame.x_26)))
      {
      struct Tree *temp_x_27;
      temp_x_27 = (frame.x_27=frame.current_node, frame.x_27->vptr->GetRight(frame.x_27));
      Interceptor(frame.current_node , temp_x_27);
      frame.current_node = temp_x_27;
      }

    else
      {
{
      cont = 0;
      ntb = (frame.x_28=frame.current_node, frame.x_28->vptr->SetHas_Right(frame.x_28, 1));
      ntb = (frame.x_29=frame.current_node, frame.x_29->vptr->SetRight(frame.x_29, frame.new_node));
}
      }

}
    }

}
  }

  prev = frame.prev;

  return (int)(1);
}
  struct Tree_Delete_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct Tree_class * current_node;
  struct Tree_class * parent_node;
  struct Tree_class * x_30;
  struct Tree_class * x_31;
  struct Tree_class * x_32;
  struct Tree_class * x_33;
  struct Tree_class * x_34;
  struct Tree_class * x_35;
  struct Tree_class * x_36;
  struct Tree_class * x_37;
  struct Tree_class * x_38;
};

int  Tree_Delete(struct Tree_class * this, int  v_key)
{
  struct Tree_Delete_gc_frame frame;

  int cont;
  int found;
  int ntb;
  int is_root;
  int key_aux;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "0";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 11;
frame.current_node = 0;
frame.parent_node = 0;
frame.x_30 = 0;
frame.x_31 = 0;
frame.x_32 = 0;
frame.x_33 = 0;
frame.x_34 = 0;
frame.x_35 = 0;
frame.x_36 = 0;
frame.x_37 = 0;
frame.x_38 = 0;

  frame.current_node = this;
  frame.parent_node = this;
  cont = 1;
  found = 0;
  is_root = 1;
  while(cont)
  {
{
  key_aux = (frame.x_30=frame.current_node, frame.x_30->vptr->GetKey(frame.x_30));
  if ((v_key) < (key_aux))
    {
    if ((frame.x_31=frame.current_node, frame.x_31->vptr->GetHas_Left(frame.x_31)))
      {
{
      Interceptor(frame.parent_node , frame.current_node);
      frame.parent_node = frame.current_node;
      struct Tree *temp_x_32;
      temp_x_32 = (frame.x_32=frame.current_node, frame.x_32->vptr->GetLeft(frame.x_32));
      Interceptor(frame.current_node , temp_x_32);
      frame.current_node = temp_x_32;
}
      }

    else
      {
      cont = 0;
      }

    }

  else
    {
    if ((key_aux) < (v_key))
      {
      if ((frame.x_33=frame.current_node, frame.x_33->vptr->GetHas_Right(frame.x_33)))
        {
{
        Interceptor(frame.parent_node , frame.current_node);
        frame.parent_node = frame.current_node;
        struct Tree *temp_x_34;
        temp_x_34 = (frame.x_34=frame.current_node, frame.x_34->vptr->GetRight(frame.x_34));
        Interceptor(frame.current_node , temp_x_34);
        frame.current_node = temp_x_34;
}
        }

      else
        {
        cont = 0;
        }

      }

    else
      {
{
      if (is_root)
        {
        if ((!((frame.x_35=frame.current_node, frame.x_35->vptr->GetHas_Right(frame.x_35)))) && (!((frame.x_36=frame.current_node, frame.x_36->vptr->GetHas_Left(frame.x_36)))))
          {
          ntb = 1;
          }

        else
          {
          ntb = (frame.x_37=this, frame.x_37->vptr->Remove(frame.x_37, frame.parent_node, frame.current_node));
          }

        }

      else
        {
        ntb = (frame.x_38=this, frame.x_38->vptr->Remove(frame.x_38, frame.parent_node, frame.current_node));
        }

      found = 1;
      cont = 0;
}
      }

    }

  is_root = 0;
}
  }

  prev = frame.prev;

  return (int)(found);
}
  struct Tree_Remove_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct Tree_class * x_39;
  struct Tree_class * x_40;
  struct Tree_class * x_41;
  struct Tree_class * x_42;
  struct Tree_class * x_43;
  struct Tree_class * x_44;
  struct Tree_class * x_45;
  struct Tree_class * x_46;
  struct Tree_class * x_47;
  struct Tree_class * x_48;
  struct Tree_class * x_49;
  struct Tree_class * x_50;
};

int  Tree_Remove(struct Tree_class * this, struct Tree_class * p_node, struct Tree_class * c_node)
{
  struct Tree_Remove_gc_frame frame;

  int ntb;
  int auxkey1;
  int auxkey2;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "11";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 12;
frame.x_39 = 0;
frame.x_40 = 0;
frame.x_41 = 0;
frame.x_42 = 0;
frame.x_43 = 0;
frame.x_44 = 0;
frame.x_45 = 0;
frame.x_46 = 0;
frame.x_47 = 0;
frame.x_48 = 0;
frame.x_49 = 0;
frame.x_50 = 0;

  if ((frame.x_39=c_node, frame.x_39->vptr->GetHas_Left(frame.x_39)))
    {
    ntb = (frame.x_40=this, frame.x_40->vptr->RemoveLeft(frame.x_40, p_node, c_node));
    }

  else
    {
    if ((frame.x_41=c_node, frame.x_41->vptr->GetHas_Right(frame.x_41)))
      {
      ntb = (frame.x_42=this, frame.x_42->vptr->RemoveRight(frame.x_42, p_node, c_node));
      }

    else
      {
{
      auxkey1 = (frame.x_43=c_node, frame.x_43->vptr->GetKey(frame.x_43));
      auxkey2 = (frame.x_45=(frame.x_44=p_node, frame.x_44->vptr->GetLeft(frame.x_44)), frame.x_45->vptr->GetKey(frame.x_45));
      if ((frame.x_46=this, frame.x_46->vptr->Compare(frame.x_46, auxkey1, auxkey2)))
        {
{
        ntb = (frame.x_47=p_node, frame.x_47->vptr->SetLeft(frame.x_47, this->my_null));
        ntb = (frame.x_48=p_node, frame.x_48->vptr->SetHas_Left(frame.x_48, 0));
}
        }

      else
        {
{
        ntb = (frame.x_49=p_node, frame.x_49->vptr->SetRight(frame.x_49, this->my_null));
        ntb = (frame.x_50=p_node, frame.x_50->vptr->SetHas_Right(frame.x_50, 0));
}
        }

}
      }

    }


  prev = frame.prev;

  return (int)(1);
}
  struct Tree_RemoveRight_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct Tree_class * x_51;
  struct Tree_class * x_52;
  struct Tree_class * x_53;
  struct Tree_class * x_54;
  struct Tree_class * x_55;
  struct Tree_class * x_56;
  struct Tree_class * x_57;
};

int  Tree_RemoveRight(struct Tree_class * this, struct Tree_class * p_node, struct Tree_class * c_node)
{
  struct Tree_RemoveRight_gc_frame frame;

  int ntb;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "11";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 7;
frame.x_51 = 0;
frame.x_52 = 0;
frame.x_53 = 0;
frame.x_54 = 0;
frame.x_55 = 0;
frame.x_56 = 0;
frame.x_57 = 0;

  while((frame.x_51=c_node, frame.x_51->vptr->GetHas_Right(frame.x_51)))
  {
{
  ntb = (frame.x_52=c_node, frame.x_52->vptr->SetKey(frame.x_52, (frame.x_54=(frame.x_53=c_node, frame.x_53->vptr->GetRight(frame.x_53)), frame.x_54->vptr->GetKey(frame.x_54))));
  Interceptor(p_node , c_node);
  p_node = c_node;
  struct Tree *temp_x_55;
  temp_x_55 = (frame.x_55=c_node, frame.x_55->vptr->GetRight(frame.x_55));
  Interceptor(c_node , temp_x_55);
  c_node = temp_x_55;
}
  }
  ntb = (frame.x_56=p_node, frame.x_56->vptr->SetRight(frame.x_56, this->my_null));
  ntb = (frame.x_57=p_node, frame.x_57->vptr->SetHas_Right(frame.x_57, 0));

  prev = frame.prev;

  return (int)(1);
}
  struct Tree_RemoveLeft_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct Tree_class * x_58;
  struct Tree_class * x_59;
  struct Tree_class * x_60;
  struct Tree_class * x_61;
  struct Tree_class * x_62;
  struct Tree_class * x_63;
  struct Tree_class * x_64;
};

int  Tree_RemoveLeft(struct Tree_class * this, struct Tree_class * p_node, struct Tree_class * c_node)
{
  struct Tree_RemoveLeft_gc_frame frame;

  int ntb;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "11";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 7;
frame.x_58 = 0;
frame.x_59 = 0;
frame.x_60 = 0;
frame.x_61 = 0;
frame.x_62 = 0;
frame.x_63 = 0;
frame.x_64 = 0;

  while((frame.x_58=c_node, frame.x_58->vptr->GetHas_Left(frame.x_58)))
  {
{
  ntb = (frame.x_59=c_node, frame.x_59->vptr->SetKey(frame.x_59, (frame.x_61=(frame.x_60=c_node, frame.x_60->vptr->GetLeft(frame.x_60)), frame.x_61->vptr->GetKey(frame.x_61))));
  Interceptor(p_node , c_node);
  p_node = c_node;
  struct Tree *temp_x_62;
  temp_x_62 = (frame.x_62=c_node, frame.x_62->vptr->GetLeft(frame.x_62));
  Interceptor(c_node , temp_x_62);
  c_node = temp_x_62;
}
  }
  ntb = (frame.x_63=p_node, frame.x_63->vptr->SetLeft(frame.x_63, this->my_null));
  ntb = (frame.x_64=p_node, frame.x_64->vptr->SetHas_Left(frame.x_64, 0));

  prev = frame.prev;

  return (int)(1);
}
  struct Tree_Search_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct Tree_class * current_node;
  struct Tree_class * x_65;
  struct Tree_class * x_66;
  struct Tree_class * x_67;
  struct Tree_class * x_68;
  struct Tree_class * x_69;
};

int  Tree_Search(struct Tree_class * this, int  v_key)
{
  struct Tree_Search_gc_frame frame;

  int ifound;
  int cont;
  int key_aux;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "0";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 6;
frame.current_node = 0;
frame.x_65 = 0;
frame.x_66 = 0;
frame.x_67 = 0;
frame.x_68 = 0;
frame.x_69 = 0;

  frame.current_node = this;
  cont = 1;
  ifound = 0;
  while(cont)
  {
{
  key_aux = (frame.x_65=frame.current_node, frame.x_65->vptr->GetKey(frame.x_65));
  if ((v_key) < (key_aux))
    {
    if ((frame.x_66=frame.current_node, frame.x_66->vptr->GetHas_Left(frame.x_66)))
      {
      struct Tree *temp_x_67;
      temp_x_67 = (frame.x_67=frame.current_node, frame.x_67->vptr->GetLeft(frame.x_67));
      Interceptor(frame.current_node , temp_x_67);
      frame.current_node = temp_x_67;
      }

    else
      {
      cont = 0;
      }

    }

  else
    {
    if ((key_aux) < (v_key))
      {
      if ((frame.x_68=frame.current_node, frame.x_68->vptr->GetHas_Right(frame.x_68)))
        {
        struct Tree *temp_x_69;
        temp_x_69 = (frame.x_69=frame.current_node, frame.x_69->vptr->GetRight(frame.x_69));
        Interceptor(frame.current_node , temp_x_69);
        frame.current_node = temp_x_69;
        }

      else
        {
        cont = 0;
        }

      }

    else
      {
{
      ifound = 1;
      cont = 0;
}
      }

    }

}
  }

  prev = frame.prev;

  return ifound;
}
  struct Tree_Print_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct Tree_class * current_node;
  struct Tree_class * x_70;
};

int  Tree_Print(struct Tree_class * this)
{
  struct Tree_Print_gc_frame frame;

  int ntb;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 2;
frame.current_node = 0;
frame.x_70 = 0;

  frame.current_node = this;
  ntb = (frame.x_70=this, frame.x_70->vptr->RecPrint(frame.x_70, frame.current_node));

  prev = frame.prev;

  return (int)(1);
}
  struct Tree_RecPrint_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct Tree_class * x_71;
  struct Tree_class * x_72;
  struct Tree_class * x_73;
  struct Tree_class * x_74;
  struct Tree_class * x_75;
  struct Tree_class * x_76;
  struct Tree_class * x_77;
};

int  Tree_RecPrint(struct Tree_class * this, struct Tree_class * node)
{
  struct Tree_RecPrint_gc_frame frame;

  int ntb;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "1";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 7;
frame.x_71 = 0;
frame.x_72 = 0;
frame.x_73 = 0;
frame.x_74 = 0;
frame.x_75 = 0;
frame.x_76 = 0;
frame.x_77 = 0;

  if ((frame.x_71=node, frame.x_71->vptr->GetHas_Left(frame.x_71)))
    {
{
    ntb = (frame.x_72=this, frame.x_72->vptr->RecPrint(frame.x_72, (frame.x_73=node, frame.x_73->vptr->GetLeft(frame.x_73))));
}
    }

  else
    {
    ntb = 1;
    }

  System_out_println ((frame.x_74=node, frame.x_74->vptr->GetKey(frame.x_74)));
  if ((frame.x_75=node, frame.x_75->vptr->GetHas_Right(frame.x_75)))
    {
{
    ntb = (frame.x_76=this, frame.x_76->vptr->RecPrint(frame.x_76, (frame.x_77=node, frame.x_77->vptr->GetRight(frame.x_77))));
}
    }

  else
    {
    ntb = 1;
    }


  prev = frame.prev;

  return (int)(1);
}
  struct Tree_accept_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct Visitor_class * x_78;
};

int  Tree_accept(struct Tree_class * this, struct Visitor_class * v)
{
  struct Tree_accept_gc_frame frame;

  int nti;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "1";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 1;
frame.x_78 = 0;

  System_out_println (333);
  nti = (frame.x_78=v, frame.x_78->vptr->visit(frame.x_78, this));

  prev = frame.prev;

  return 0;
}
  struct Visitor_visit_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct Tree_class * x_79;
  struct Tree_class * x_80;
  struct Tree_class * x_81;
  struct Tree_class * x_82;
  struct Tree_class * x_83;
  struct Tree_class * x_84;
};

int  Visitor_visit(struct Visitor_class * this, struct Tree_class * n)
{
  struct Visitor_visit_gc_frame frame;

  int nti;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "1";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 6;
frame.x_79 = 0;
frame.x_80 = 0;
frame.x_81 = 0;
frame.x_82 = 0;
frame.x_83 = 0;
frame.x_84 = 0;

  if ((frame.x_79=n, frame.x_79->vptr->GetHas_Right(frame.x_79)))
    {
{
    struct Tree *temp_x_80;
    temp_x_80 = (frame.x_80=n, frame.x_80->vptr->GetRight(frame.x_80));
    Interceptor(this->r , temp_x_80);
    this->r = temp_x_80;
    nti = (frame.x_81=this->r, frame.x_81->vptr->accept(frame.x_81, this));
}
    }

  else
    {
    nti = 0;
    }

  if ((frame.x_82=n, frame.x_82->vptr->GetHas_Left(frame.x_82)))
    {
{
    struct Tree *temp_x_83;
    temp_x_83 = (frame.x_83=n, frame.x_83->vptr->GetLeft(frame.x_83));
    Interceptor(this->l , temp_x_83);
    this->l = temp_x_83;
    nti = (frame.x_84=this->l, frame.x_84->vptr->accept(frame.x_84, this));
}
    }

  else
    {
    nti = 0;
    }


  prev = frame.prev;

  return 0;
}
  struct MyVisitor_visit_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct Tree_class * x_85;
  struct Tree_class * x_86;
  struct Tree_class * x_87;
  struct Tree_class * x_88;
  struct Tree_class * x_89;
  struct Tree_class * x_90;
  struct Tree_class * x_91;
};

int  MyVisitor_visit(struct MyVisitor_class * this, struct Tree_class * n)
{
  struct MyVisitor_visit_gc_frame frame;

  int nti;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "1";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 7;
frame.x_85 = 0;
frame.x_86 = 0;
frame.x_87 = 0;
frame.x_88 = 0;
frame.x_89 = 0;
frame.x_90 = 0;
frame.x_91 = 0;

  if ((frame.x_85=n, frame.x_85->vptr->GetHas_Right(frame.x_85)))
    {
{
    struct Tree *temp_x_86;
    temp_x_86 = (frame.x_86=n, frame.x_86->vptr->GetRight(frame.x_86));
    Interceptor(this->r , temp_x_86);
    this->r = temp_x_86;
    nti = (frame.x_87=this->r, frame.x_87->vptr->accept(frame.x_87, this));
}
    }

  else
    {
    nti = 0;
    }

  System_out_println ((frame.x_88=n, frame.x_88->vptr->GetKey(frame.x_88)));
  if ((frame.x_89=n, frame.x_89->vptr->GetHas_Left(frame.x_89)))
    {
{
    struct Tree *temp_x_90;
    temp_x_90 = (frame.x_90=n, frame.x_90->vptr->GetLeft(frame.x_90));
    Interceptor(this->l , temp_x_90);
    this->l = temp_x_90;
    nti = (frame.x_91=this->l, frame.x_91->vptr->accept(frame.x_91, this));
}
    }

  else
    {
    nti = 0;
    }


  prev = frame.prev;

  return 0;
}

// vtables
struct TreeVisitor_vtable TreeVisitor_vtable_ = 
{
  ""
};

struct TV_vtable TV_vtable_ = 
{
  "",
  TV_Start
};

struct Tree_vtable Tree_vtable_ = 
{
  "110001",
  Tree_Init,
  Tree_SetRight,
  Tree_SetLeft,
  Tree_GetRight,
  Tree_GetLeft,
  Tree_GetKey,
  Tree_SetKey,
  Tree_GetHas_Right,
  Tree_GetHas_Left,
  Tree_SetHas_Left,
  Tree_SetHas_Right,
  Tree_Compare,
  Tree_Insert,
  Tree_Delete,
  Tree_Remove,
  Tree_RemoveRight,
  Tree_RemoveLeft,
  Tree_Search,
  Tree_Print,
  Tree_RecPrint,
  Tree_accept
};

struct Visitor_vtable Visitor_vtable_ = 
{
  "11",
  Visitor_visit
};

struct MyVisitor_vtable MyVisitor_vtable_ = 
{
  "11",
  MyVisitor_visit
};


// main method
  struct main_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct TV_class* x_0;
};
int Tiger_main ()
{
  struct main_gc_frame frame;

  prev = 0;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "";
  frame.arguments_base_address = 0;
  frame.locals_gc_count = 1;
  System_out_println ((frame.x_0=((struct TV_class*)(Tiger_new (&TV_vtable_, sizeof(struct TV_class)/4 ))), frame.x_0->vptr->Start(frame.x_0)));
}




