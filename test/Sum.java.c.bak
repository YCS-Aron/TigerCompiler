// This is automatically generated by the Tiger compiler.
// Do NOT modify!

extern void* prev;
//vtable structures declaration
struct Sum_vtable;
struct Doit_vtable;
// structures
struct Sum
{
  struct Sum_vtable *vptr;
};
struct Doit
{
  struct Doit_vtable *vptr;
};
// vtables structures
struct Sum_vtable
{
char* Sum_gc_map;
};

struct Doit_vtable
{
char* Doit_gc_map;
  int  (*doit)(struct Doit *this,int  n);
};


// forward declare vtable
struct Sum_vtable Sum_vtable_; 
struct Doit_vtable Doit_vtable_; 
// methods
  struct doit_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  int * h;
};

int  Doit_doit(struct Doit * this, int  n)
{
  struct doit_gc_frame frame;

	printf("this is doit\n");

  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "0";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 1;

  frame.h = (int*)Tiger_new_array (10);
	printf("pointer %p\n",frame.h);

  frame.h[5] = 777;
//  printf("pointer %p\nsize %d\ndata[5] %d ",frame.h,*(frame.h+2),*(frame.h+9));

  prev = frame.prev;

  return frame.h[5];
}

// vtables
struct Sum_vtable Sum_vtable_ = 
{
  ""
};

struct Doit_vtable Doit_vtable_ = 
{
  "",
  Doit_doit
};


// main method
  struct main_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct Doit* x_0;
};

int Tiger_main ()
{
  printf("this is tiger_main\n");

  struct main_gc_frame frame;
//  frame.prev = prev;
//  prev = &frame;
//  frame.arguments_gc_map = "";
//  frame.arguments_base_address = 0;
//  frame.locals_gc_count = 1;
//  System_out_println ((frame.x_0=((struct Doit*)(Tiger_new (&Doit_vtable_, sizeof(struct Doit)))), frame.x_0->vptr->doit(frame.x_0, 101)));
}




