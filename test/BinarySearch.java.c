// This is automatically generated by the Tiger compiler.
// Do NOT modify!

extern void* prev;
//vtable structures declaration
struct BinarySearch_vtable;
struct BS_vtable;
// structures
struct BinarySearch_class
{
  struct BinarySearch_vtable *vptr;
int isObjOrArray;
void *forwarding;
unsigned mark;
};
struct BS_class
{
  struct BS_vtable *vptr;
int isObjOrArray;
void *forwarding;
unsigned mark;
int * number;
int size;
};
// vtables structures
struct BinarySearch_vtable
{
char* BinarySearch_gc_map;
};

struct BS_vtable
{
char* BS_gc_map;
  int  (*Start)(struct BS_class *this,int  sz);
  int  (*Search)(struct BS_class *this,int  num);
  int  (*Div)(struct BS_class *this,int  num);
  int  (*Compare)(struct BS_class *this,int  num1,int  num2);
  int  (*Print)(struct BS_class *this);
  int  (*Init)(struct BS_class *this,int  sz);
};


// forward declare vtable
struct BinarySearch_vtable BinarySearch_vtable_; 
struct BS_vtable BS_vtable_; 
// methods
  struct BS_Start_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct BS_class * x_1;
  struct BS_class * x_2;
  struct BS_class * x_3;
  struct BS_class * x_4;
  struct BS_class * x_5;
  struct BS_class * x_6;
  struct BS_class * x_7;
  struct BS_class * x_8;
  struct BS_class * x_9;
  struct BS_class * x_10;
};

int  BS_Start(struct BS_class * this, int  sz)
{
  struct BS_Start_gc_frame frame;

  int aux01;
  int aux02;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "0";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 10;
frame.x_1 = 0;
frame.x_2 = 0;
frame.x_3 = 0;
frame.x_4 = 0;
frame.x_5 = 0;
frame.x_6 = 0;
frame.x_7 = 0;
frame.x_8 = 0;
frame.x_9 = 0;
frame.x_10 = 0;

  aux01 = (frame.x_1=this, frame.x_1->vptr->Init(frame.x_1, sz));
  aux02 = (frame.x_2=this, frame.x_2->vptr->Print(frame.x_2));
  if ((frame.x_3=this, frame.x_3->vptr->Search(frame.x_3, 8)))
    {
    System_out_println (1);
    }

  else
    {
    System_out_println (0);
    }

  if ((frame.x_4=this, frame.x_4->vptr->Search(frame.x_4, 19)))
    {
    System_out_println (1);
    }

  else
    {
    System_out_println (0);
    }

  if ((frame.x_5=this, frame.x_5->vptr->Search(frame.x_5, 20)))
    {
    System_out_println (1);
    }

  else
    {
    System_out_println (0);
    }

  if ((frame.x_6=this, frame.x_6->vptr->Search(frame.x_6, 21)))
    {
    System_out_println (1);
    }

  else
    {
    System_out_println (0);
    }

  if ((frame.x_7=this, frame.x_7->vptr->Search(frame.x_7, 37)))
    {
    System_out_println (1);
    }

  else
    {
    System_out_println (0);
    }

  if ((frame.x_8=this, frame.x_8->vptr->Search(frame.x_8, 38)))
    {
    System_out_println (1);
    }

  else
    {
    System_out_println (0);
    }

  if ((frame.x_9=this, frame.x_9->vptr->Search(frame.x_9, 39)))
    {
    System_out_println (1);
    }

  else
    {
    System_out_println (0);
    }

  if ((frame.x_10=this, frame.x_10->vptr->Search(frame.x_10, 50)))
    {
    System_out_println (1);
    }

  else
    {
    System_out_println (0);
    }


  prev = frame.prev;

  return 999;
}
  struct BS_Search_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct BS_class * x_11;
  struct BS_class * x_12;
  struct BS_class * x_13;
};

int  BS_Search(struct BS_class * this, int  num)
{
  struct BS_Search_gc_frame frame;

  int bs01;
  int right;
  int left;
  int var_cont;
  int medium;
  int aux01;
  int nt;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "0";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 3;
frame.x_11 = 0;
frame.x_12 = 0;
frame.x_13 = 0;

  aux01 = 0;
  bs01 = 0;
  right = *((this->number)+2);
  right = right - 1;
  left = 0;
  var_cont = 1;
  while(var_cont)
  {
{
  medium = left + right;
  medium = (frame.x_11=this, frame.x_11->vptr->Div(frame.x_11, medium));
  aux01 = this->number[medium];
  if ((num) < (aux01))
    {
    right = medium - 1;
    }

  else
    {
    left = medium + 1;
    }

  if ((frame.x_12=this, frame.x_12->vptr->Compare(frame.x_12, aux01, num)))
    {
    var_cont = 0;
    }

  else
    {
    var_cont = 1;
    }

  if ((right) < (left))
    {
    var_cont = 0;
    }

  else
    {
    nt = 0;
    }

}
  }
  if ((frame.x_13=this, frame.x_13->vptr->Compare(frame.x_13, aux01, num)))
    {
    bs01 = 1;
    }

  else
    {
    bs01 = 0;
    }


  prev = frame.prev;

  return (int)(bs01);
}
  struct BS_Div_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

int  BS_Div(struct BS_class * this, int  num)
{
  struct BS_Div_gc_frame frame;

  int count01;
  int count02;
  int aux03;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "0";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;

  count01 = 0;
  count02 = 0;
  aux03 = num - 1;
  while((count02) < (aux03))
  {
{
  count01 = count01 + 1;
  count02 = count02 + 2;
}
  }

  prev = frame.prev;

  return count01;
}
  struct BS_Compare_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

int  BS_Compare(struct BS_class * this, int  num1, int  num2)
{
  struct BS_Compare_gc_frame frame;

  int retval;
  int aux02;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "00";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;

  retval = 0;
  aux02 = num2 + 1;
  if ((num1) < (num2))
    {
    retval = 0;
    }

  else
    {
    if (!((num1) < (aux02)))
      {
      retval = 0;
      }

    else
      {
      retval = 1;
      }

    }


  prev = frame.prev;

  return (int)(retval);
}
  struct BS_Print_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

int  BS_Print(struct BS_class * this)
{
  struct BS_Print_gc_frame frame;

  int j;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;

  j = 1;
  while((j) < (this->size))
  {
{
  System_out_println (this->number[j]);
  j = j + 1;
}
  }
  System_out_println (99999);

  prev = frame.prev;

  return 0;
}
  struct BS_Init_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
};

int  BS_Init(struct BS_class * this, int  sz)
{
  struct BS_Init_gc_frame frame;

  int j;
  int k;
  int aux02;
  int aux01;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "0";
  frame.arguments_base_address = (int*)&this;
  frame.locals_gc_count = 0;

  this->size = sz;
  int *tempttt = (int*)Tiger_new_array (sz);
  this->number = tempttt;
  j = 1;
  k = this->size + 1;
  while((j) < (this->size))
  {
{
  aux01 = 2 * j;
  aux02 = k - 2;
  this->number[j] = aux01 + aux02;
  j = j + 1;
  k = k - 1;
}
  }

  prev = frame.prev;

  return 0;
}

// vtables
struct BinarySearch_vtable BinarySearch_vtable_ = 
{
  ""
};

struct BS_vtable BS_vtable_ = 
{
  "10",
  BS_Start,
  BS_Search,
  BS_Div,
  BS_Compare,
  BS_Print,
  BS_Init
};


// main method
  struct main_gc_frame
{
  void *prev;
  char *arguments_gc_map;
  int *arguments_base_address;
  int locals_gc_count;
  struct BS_class* x_0;
};
int Tiger_main ()
{
  struct main_gc_frame frame;

  prev = 0;
  frame.prev = prev;
  prev = &frame;
  frame.arguments_gc_map = "";
  frame.arguments_base_address = 0;
  frame.locals_gc_count = 1;
  System_out_println ((frame.x_0=((struct BS_class*)(Tiger_new (&BS_vtable_, sizeof(struct BS_class)/4 ))), frame.x_0->vptr->Start(frame.x_0, 20)));
}




